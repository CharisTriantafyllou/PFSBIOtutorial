---
title: "Single cell RNA-seq tutorial"
author: "Charisios Triantafyllou"
date: "Friday 28/04/2023"
output:
  html_document:
    toc: yes
    df_print: paged
  unilur::tutorial_html:
    toc: yes
    toc_float: yes
    theme: default
    number_sections: yes
  unilur::tutorial_pdf:
    number_sections: yes
  unilur::tutorial_pdf_solution:
    number_sections: yes
  unilur::tutorial_html_solution:
    toc: yes
    toc_float: yes
    solution_suffix: ''
    theme: default
    number_sections: yes
urlcolor: blue
---

```{r setup, include=FALSE,purl=FALSE}
knitr::opts_template$set(solution = list(box.title = "Answer",
                                         box.body = list(fill = "white"),
                                         box.collapse = FALSE))
knitr::opts_chunk$set(echo=TRUE,comment="#",fig.path='Figures/Figure-',fig.align='center',fig.width=8,fig.height=8,out.width="65%",fig.show="hold")

r <- getOption("repos")
r["CRAN"] <- "https://cloud.r-project.org/"
options(repos = r)
```


# Intro

This tutorial is focused on the analysis of single-cell RNA-seq data using the R environment and Bioconductor software. The aim of this material is to introduce the student to some of the most representative methods and corresponding tasks of state-of-the-art transcriptomic analysis.

- Quality control and Filtering 
- Normalization and Dimensionality reduction
- Clustering and Visualization
- SCTransform Normalization and Clustering
- Differential Expression
- Cell annotation

# Preparations

In this step we set up the environment including data and required libraries. 

## Load Packages

We load the required libraries to make use of the functions and methods they include.

```{r load_packages,warning=FALSE,message=FALSE}
library(Seurat)
library(ggplot2)
library(SingleR)
library(dplyr)
library(celldex)
library(RColorBrewer)
library(SingleCellExperiment)
library(glmGamPoi)
```

## Load dataset

As a first step we import a count matrix that had previously undergone ambient RNA correction and doublet detection using the tools soupX and scrublet respectively. Features are labels by gene symbol and so the function is called with default options. 

```{r import_data, warning=FALSE}
adj.matrix <- Read10X("data/update/soupX_pbmc10k_filt")
```

## Make a Seurat object

Next we create a Seurat object which is a custom type of S4 object in R environment. It allows us to keep our data tidy and enrich them with more without losing track of the original situation. The object summary shows us that there is information about 10194 samples (here cells) are 36601 genes (features).

```{r}
srat <- CreateSeuratObject(adj.matrix,project = "pbmc10k") 
srat
```
It is better to remove the matrix now, to save some RAM memory.

```{r srat_summary}
adj.matrix <- NULL
str(srat)
```

In order to access metadata we use @ and [[]]. The meta.data field is dynamic and for now it has 3 fields per cell: dataset ID, number of UMI reads detected per cell (nCount_RNA), and the number of expressed (detected) genes per same cell (nFeature_RNA).

```{r}
meta <- srat@meta.data
dim(meta)
```


```{r}
head(meta)
```

# Quality Control and filtering

Let’s add several more values useful in diagnostics of cell quality. Michochondrial genes are useful indicators of cell state. For mouse datasets, change pattern to “Mt-,” or explicitly list gene IDs with the features = … option.

```{r}
srat[["percent.mt"]] <- PercentageFeatureSet(srat, pattern = "^MT-")
```


Similarly, we can define ribosomal proteins (their names begin with RPS or RPL), which often take substantial fraction of reads:

```{r}
srat[["percent.rb"]] <- PercentageFeatureSet(srat, pattern = "^RP[SL]")
```


Now, let’s add the doublet annotation generated by scrublet to the Seurat object metadata.

```{r}
doublets <- read.table("data/update/scrublet_calls.tsv",header = F,row.names = 1)
colnames(doublets) <- c("Doublet_score","Is_doublet")
srat <- AddMetaData(srat,doublets)
head(srat[[]])
```


Let’s make violin plots of the selected metadata features. Note that the plots are grouped by categories named identity class. Identity class can be seen in srat@active.ident, or using Idents() function. Active identity can be changed using SetIdents().

```{r}
VlnPlot(srat, features = c("nFeature_RNA","nCount_RNA","percent.mt","percent.rb"),ncol = 4,pt.size = 0.1) & theme(plot.title = element_text(size=10))
```


Let’s plot some of the metadata features against each other and see how they correlate. The number above each plot is a Pearson correlation coefficient.

```{r}
FeatureScatter(srat, feature1 = "nCount_RNA", feature2 = "percent.mt")
```

```{r}
FeatureScatter(srat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
```

```{r}
FeatureScatter(srat, feature1 = "nCount_RNA", feature2 = "percent.rb")
```

```{r}
FeatureScatter(srat, feature1 = "percent.rb", feature2 = "percent.mt")
```

```{r}
FeatureScatter(srat, feature1 = "nFeature_RNA", feature2 = "Doublet_score")
```

The plots above clearly show that high MT percentage strongly correlates with low UMI counts, and usually is interpreted as dead cells. High ribosomal protein content, however, strongly anti-correlates with MT, and seems to contain biological signal. There’s also a strong correlation between the doublet score and number of expressed genes. Let’s set QC column in metadata and define it in an informative way.


```{r}
srat[['QC']] <- ifelse(srat@meta.data$Is_doublet == 'True','Doublet','Pass')
srat[['QC']] <- ifelse(srat@meta.data$nFeature_RNA < 500 & srat@meta.data$QC == 'Pass','Low_nFeature',srat@meta.data$QC)
srat[['QC']] <- ifelse(srat@meta.data$nFeature_RNA < 500 & srat@meta.data$QC != 'Pass' & srat@meta.data$QC != 'Low_nFeature',paste('Low_nFeature',srat@meta.data$QC,sep = ','),srat@meta.data$QC)
srat[['QC']] <- ifelse(srat@meta.data$percent.mt > 15 & srat@meta.data$QC == 'Pass','High_MT',srat@meta.data$QC)
srat[['QC']] <- ifelse(srat@meta.data$nFeature_RNA < 500 & srat@meta.data$QC != 'Pass' & srat@meta.data$QC != 'High_MT',paste('High_MT',srat@meta.data$QC,sep = ','),srat@meta.data$QC)
table(srat[['QC']])
```

We can see that doublets don’t often overlap with cell with low number of detected genes; at the same time, the latter often co-insides with high mitochondrial content. Let’s plot metadata only for cells that pass tentative QC:

```{r}
VlnPlot(subset(srat, subset = QC == 'Pass'), features = c("nFeature_RNA", "nCount_RNA", "percent.mt","percent.rb"), ncol = 4, pt.size = 0.1) & theme(plot.title = element_text(size=10))
```


# Normalization and dimensionality reduction

## Normalization and scaling

In order to do further analysis, we need to normalize the data to account for sequencing depth. Conventional way is to scale it to 10,000 (as if all cells have 10k UMIs overall), and log2-transform the obtained values. Normalized data are stored in srat[['RNA']]@data of the ‘RNA’ assay.

```{r}
srat <- NormalizeData(srat)
```

Next step discovers the most variable features (genes) - these are usually most interesting for downstream analysis.

```{r}
srat <- FindVariableFeatures(srat, selection.method = "vst", nfeatures = 2000)
```

Identify the 10 most highly variable genes:
```{r}
top10 <- head(VariableFeatures(srat), 10)
top10 
```

Plot variable features with and without labels:
```{r, warning=FALSE}
plot1 <- VariableFeaturePlot(srat)
LabelPoints(plot = plot1, points = top10, repel = TRUE, xnudge = 0, ynudge = 0)
```


ScaleData converts normalized gene expression to Z-score (values centered at 0 and with variance of 1). It’s stored in srat[['RNA']]@scale.data and used in following PCA. Default is to run scaling only on variable genes.
```{r}
all.genes <- rownames(srat)
srat <- ScaleData(srat, features = all.genes)
```

## PCA transformation

We can now do PCA, which is a common way of linear dimensionality reduction. By default we use 2000 most variable genes.

```{r}
srat <- RunPCA(srat, features = VariableFeatures(object = srat))

```


Principal component “loadings” should match markers of distinct populations for well behaved datasets. Note that you can change many plot parameters using ggplot2 features - passing them with & operator.

```{r}
VizDimLoadings(srat, dims = 1:9, reduction = "pca") & theme(axis.text=element_text(size=5), axis.title=element_text(size=8,face="bold"))
```


```{r}
DimPlot(srat, reduction = "pca")
```
It’s often good to find how many PCs can be used without much information loss. In our case a big drop happens at 10, so seems like a good initial choice:

```{r}
ElbowPlot(srat)
```

# Clustering and Visualization

## Cluster annotation

We can now do clustering. Higher resolution leads to more clusters (default is 0.8). It would be very important to find the correct cluster resolution in the future, since cell type markers depends on cluster definition.

```{r}
srat <- FindNeighbors(srat, dims = 1:10)
```

```{r}
srat <- FindClusters(srat, resolution = 0.5)
```
## UMAP visualization

For visualization purposes, we also need to generate UMAP reduced dimensionality representation:

```{r, warning=FALSE}
srat <- RunUMAP(srat, dims = 1:10, verbose = F)
```

Once clustering is done, active identity is reset to clusters (“seurat_clusters” in metadata). Let’s look at cluster sizes.

```{r}
table(srat@meta.data$seurat_clusters)
```

DimPlot uses UMAP by default, with Seurat clusters as identity:

```{r}
DimPlot(srat,label.size = 4,repel = T,label = T)
```

In order to control for clustering resolution and other possible artifacts, we will take a close look at two minor cell populations: 1) dendritic cells (DCs), 2) platelets, aka thrombocytes. Let’s visualise two markers for each of this cell type: LILRA4 and TPM2 for DCs, and PPBP and GP1BB for platelets.

```{r}
FeaturePlot(srat, features = c("LILRA4", "TPM2", "PPBP", "GP1BB"))
```
Based on this we expect cluster 11 to correspond to DCs and cluster 12 to platelets.

Let’s visualize other confounders:

```{r}
FeaturePlot(srat, features = "nFeature_RNA") & theme(plot.title = element_text(size=10))
```
Based on the plot, cluster 11, which probably corresponds to DCs seems to have more features (genes) compared to other clusters and the same goes for cluster 10. These observations are based on color.


Let’s remove the cells that did not pass QC and compare plots. We can now see much more defined clusters. Our filtered dataset now contains 8824 cells - so approximately 12% of cells were removed for various reasons.

```{r}
DimPlot(srat,label.size = 4,repel = T,label = T)
```

```{r}
srat <- subset(srat, subset = QC == 'Pass')
DimPlot(srat,label.size = 4,repel = T,label = T)
```


Finally, we calculate cell cycle scores, as described [in this tutorial](https://satijalab.org/seurat/archive/v3.1/cell_cycle_vignette.html). This has to be done after normalization and scaling. Seurat has a built-in list, cc.genes (older) and cc.genes.updated.2019 (newer), that defines genes involved in cell cycle. For CellRanger reference GRCh38 2.0.0 and above, use cc.genes.updated.2019 (three genes were renamed: MLF1IP, FAM64A and HN1 became CENPU, PICALM and JPT). For mouse cell cycle genes you can use the solution detailed here.

```{r}
cc.genes.updated.2019
```

We assign the gene names to new variables.
```{r}
s.genes <- cc.genes.updated.2019$s.genes
g2m.genes <- cc.genes.updated.2019$g2m.genes
```

We update the srat object with this information.
```{r}
srat <- CellCycleScoring(srat, s.features = s.genes, g2m.features = g2m.genes)
table(srat[[]]$Phase)
```

This information will be used for normalization using SCTransform command.


#SCTransform normalization and clustering

Seurat package offers the ability to perform the normalization, scaling and dimensionality reduction steps with the command SCTransform that replaces the commands NormalizeData, ScaleData, and FindVariableFeatures. This method of normalization was shown to be beneficial for finding rare cell populations by improving signal/noise ratio. However it is highly recommended to perform extensive QC with doublet and empty cell removal before using this.

While using this We will also correct for % MT genes and cell cycle scores using vars.to.regress variables; our previous exploration has shown that neither cell cycle score nor MT percentage change very dramatically between clusters, so we will not remove biological signal, but only some unwanted variation.

## Transform 

```{r}
srat <- SCTransform(srat, method = "glmGamPoi", ncells = 8824, 
                    vars.to.regress = c("percent.mt","S.Score","G2M.Score"), verbose = F)
srat
```

## Dimensionality reduction and Clustering

After this let’s do standard PCA, UMAP, and clustering. Note that SCT is the active assay now. It is conventional to use more PCs with SCTransform; the exact number can be adjusted depending on your dataset.

```{r}
srat <- RunPCA(srat, verbose = F)
srat <- RunUMAP(srat, dims = 1:30, verbose = F)
srat <- FindNeighbors(srat, dims = 1:30, verbose = F)
srat <- FindClusters(srat, verbose = F)
table(srat[[]]$seurat_clusters)
```

```{r}
DimPlot(srat, label = T)
```

We can use markers to select and visualise cell population of specific type.

```{r, message=FALSE,warning=FALSE}
FeaturePlot(srat,"MS4A1") + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("MS4A1: B cells")
```

```{r, message=FALSE,warning=FALSE}
FeaturePlot(srat,"CD8B") + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("CD8B: CD8 T cells")
```


```{r, message=FALSE,warning=FALSE}
FeaturePlot(srat,"IL7R") + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("IL7R: CD4 T cells")
```



# Differential Expression

Differential expression allows us to define gene markers specific to each cluster. By definition it is influenced by how clusters are defined, so it’s important to find the correct resolution of your clustering before defining the markers. If some clusters lack any notable markers, adjust the clustering. It is recommended to do differential expression on the RNA assay, and not the SCTransform. Differential expression can be done between two specific clusters, as well as between a cluster and all other cells.

## Prepparation

First, let’s set the active assay back to “RNA,” and re-do the normalization and scaling (since we removed a notable fraction of cells that failed QC):


```{r}
DefaultAssay(srat) <- "RNA"
srat <- NormalizeData(srat)
srat <- FindVariableFeatures(srat, selection.method = "vst", nfeatures = 2000)
all.genes <- rownames(srat)
srat <- ScaleData(srat, features = all.genes)
```

The following function allows to find markers for every cluster by comparing it to all remaining cells, while reporting only the positive ones. There are many tests that can be used to define markers, including a very fast and intuitive tf-idf. By default, Wilcoxon Rank Sum test is used. This takes a while - take few minutes to make coffee or a cup of tea! For speed, we have increased the default minimal percentage and log2FC cutoffs; these should be adjusted to suit your dataset!

## Marker identification

```{r}
all.markers <- FindAllMarkers(srat, only.pos = T, min.pct = 0.5, logfc.threshold = 0.5)
```

```{r}
dim(all.markers)
```

```{r}
table(all.markers$cluster)
```

```{r}
top3_markers <- as.data.frame(all.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC))
top3_markers
```

Some markers are less informative than others. For detailed dissection, it might be good to do differential expression between subclusters (see below).


# Cell type Annotation

Given the markers that we’ve defined, we can mine the literature and identify each observed cell type (it’s probably the easiest for PBMC). However, we can try automaic annotation with SingleR is workflow-agnostic (can be used with Seurat, SCE, etc). Detailed signleR manual with advanced usage can be found here.

Let’s get reference datasets from celldex package. Note that there are two cell type assignments, label.main and label.fine. We’re only going to run the annotation against the Monaco Immune Database, but you can uncomment the two others to compare the automated annotations generated

```{r}
monaco.ref <- celldex::MonacoImmuneData()
# hpca.ref <- celldex::HumanPrimaryCellAtlasData()
# dice.ref <- celldex::DatabaseImmuneCellExpressionData()
```

Let’s convert our Seurat object to single cell experiment (SCE) for convenience. After this, using SingleR becomes very easy:

```{r}
sce <- as.SingleCellExperiment(DietSeurat(srat))
sce
```

```{r}
monaco.main <- SingleR(test = sce,assay.type.test = 1,ref = monaco.ref,labels = monaco.ref$label.main)
monaco.fine <- SingleR(test = sce,assay.type.test = 1,ref = monaco.ref,labels = monaco.ref$label.fine)
# hpca.main <- SingleR(test = sce,assay.type.test = 1,ref = hpca.ref,labels = hpca.ref$label.main)
# hpca.fine <- SingleR(test = sce,assay.type.test = 1,ref = hpca.ref,labels = hpca.ref$label.fine)
# dice.main <- SingleR(test = sce,assay.type.test = 1,ref = dice.ref,labels = dice.ref$label.main)
# dice.fine <- SingleR(test = sce,assay.type.test = 1,ref = dice.ref,labels = dice.ref$label.fine)
```


Let’s see the summary of general cell type annotations. These match our expectations (and each other) reasonably well.

```{r}
table(monaco.main$pruned.labels)
```

```{r}
#table(hpca.main$pruned.labels)
#table(dice.main$pruned.labels)
```

The finer cell types annotations are you after, the harder they are to get reliably. This is where comparing many databases, as well as using individual markers from literature, would all be very valuable.

```{r}
table(monaco.fine$pruned.labels)
```


Let’s add the annotations to the Seurat object metadata so we can use them:


```{r}
srat@meta.data$monaco.main <- monaco.main$pruned.labels
srat@meta.data$monaco.fine <- monaco.fine$pruned.labels

# srat@meta.data$hpca.main   <- hpca.main$pruned.labels
# srat@meta.data$dice.main   <- dice.main$pruned.labels
# srat@meta.data$hpca.fine   <- hpca.fine$pruned.labels
# srat@meta.data$dice.fine   <- dice.fine$pruned.labels
```

Finally, let’s visualize the fine-grained annotations.

```{r, warning=FALSE}
srat <- SetIdent(srat, value = "monaco.fine")
DimPlot(srat, label = T , repel = T, label.size = 3) + NoLegend()
```


Comparing the labels obtained from the three sources, we can see many interesting discrepancies. Sorting those out requires manual curation. In addition we can see the expression of known and new markers to each corresponding population and subpopulation. For example CD8 T cells and MAIT T cells.

```{r, message=FALSE, warning=FALSE}
FeaturePlot(srat,"CD8B") + scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
```



```{r, message=FALSE, warning=FALSE}
FeaturePlot(srat,"KLRB1") + scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))

```



# Acknowledgements
This tutorial is based on a [fantastic course](https://github.com/cellgeni/scRNA.seq.course) focused on scRNA-seq, offered by the [Hemberg Group](https://www.sanger.ac.uk/group/hemberg-group/) at Welcome Sanger Institute, UK. The tutorial is accompanied by an excellent Review Article at Nature Protocols [Tutorial: guidelines for the computational analysis of single-cell RNA sequencing data](https://www.nature.com/articles/s41596-020-00409-w) that was of great assistance for my understanding of the topic. Many thanks to the team for publishing this thorough and helpful material.






